<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · CausalELM</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://dscolby.github.io/CausalELM.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.jpg" alt="CausalELM logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">CausalELM</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../guide/estimatorselection/">Deciding Which Estimator to Use</a></li><li><a class="tocitem" href="../guide/its/">Interrupted Time Series Estimation</a></li><li><a class="tocitem" href="../guide/gcomputation/">G-computation</a></li><li><a class="tocitem" href="../guide/doublemachinelearning/">Double Machine Learning</a></li><li><a class="tocitem" href="../guide/metalearners/">Metalearners</a></li><li><a class="tocitem" href="../guide/doublyrobust/">Doubly Robust Estimation</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Activation-Functions"><span>Activation Functions</span></a></li><li><a class="tocitem" href="#Cross-Validation"><span>Cross Validation</span></a></li><li><a class="tocitem" href="#Average-Causal-Effect-Estimators"><span>Average Causal Effect Estimators</span></a></li><li><a class="tocitem" href="#Metalearners"><span>Metalearners</span></a></li><li><a class="tocitem" href="#Common-Methods"><span>Common Methods</span></a></li><li><a class="tocitem" href="#Inference"><span>Inference</span></a></li><li><a class="tocitem" href="#Model-Validation"><span>Model Validation</span></a></li><li><a class="tocitem" href="#Validation-Metrics"><span>Validation Metrics</span></a></li><li><a class="tocitem" href="#Extreme-Learning-Machines"><span>Extreme Learning Machines</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../release_notes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dscolby/CausalELM.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CausalELM"><a class="docs-heading-anchor" href="#CausalELM">CausalELM</a><a id="CausalELM-1"></a><a class="docs-heading-anchor-permalink" href="#CausalELM" title="Permalink"></a></h1><p>Most of the methods and structs here are private, not exported, should not be called by the  user, and are documented for the purpose of developing CausalELM or to facilitate  understanding of the implementation.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalELM.InterruptedTimeSeries" href="#CausalELM.InterruptedTimeSeries"><code>CausalELM.InterruptedTimeSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InterruptedTimeSeries(X₀, Y₀, X₁, Y₁; &lt;keyword arguments&gt;)</code></pre><p>Initialize an interrupted time series estimator. </p><p>For a simple linear regression-based tutorial on interrupted time series analysis see:     Bernal, James Lopez, Steven Cummins, and Antonio Gasparrini. &quot;Interrupted time series      regression for the evaluation of public health interventions: a tutorial.&quot; International      journal of epidemiology 46, no. 1 (2017): 348-355.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>X₀::Any</code>: an array or DataFrame of covariates from the pre-treatment period.</li><li><code>Y₁::Any</code>: an array or DataFrame of outcomes from the pre-treatment period.</li><li><code>X₁::Any</code>: an array or DataFrame of covariates from the post-treatment period.</li><li><code>Y₀::Any</code>: an array or DataFrame of outcomes from the post-treatment period.</li><li><code>regularized::Function=true</code>: whether to use L2 regularization</li><li><code>activation::Function=relu</code>: the activation function to use.</li><li><code>validation_metric::Function</code>: the validation metric to calculate during cross validation.</li><li><code>min_neurons::Int</code>: the minimum number of neurons to consider for the extreme learner.</li><li><code>max_neurons::Int</code>: the maximum number of neurons to consider for the extreme learner.</li><li><code>folds::Int</code>: the number of folds to use for cross validation.</li><li><code>iterations::Int</code>: the number of iterations to perform cross validation between    min<em>neurons and max</em>neurons.</li><li><code>approximator_neurons::Int</code>: the number of nuerons in the validation loss approximator    network.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X₀, Y₀, X₁, Y₁ =  rand(100, 5), rand(100), rand(10, 5), rand(10)
julia&gt; m1 = InterruptedTimeSeries(X₀, Y₀, X₁, Y₁)
julia&gt; m2 = InterruptedTimeSeries(X₀, Y₀, X₁, Y₁; regularized=false)
julia&gt; x₀_df = DataFrame(x1=rand(100), x2=rand(100), x3=rand(100))
julia&gt; y₀_df = DataFrame(y=rand(100))
julia&gt; x₁_df = DataFrame(x1=rand(100), x2=rand(100), x3=rand(100)) 
julia&gt; y₁_df = DataFrame(y=rand(100))
julia&gt; m3 = InterruptedTimeSeries(x₀_df, y₀_df, x₁_df, y₁_df)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/estimators.jl#L4-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.GComputation" href="#CausalELM.GComputation"><code>CausalELM.GComputation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GComputation(X, T, Y; &lt;keyword arguments&gt;)</code></pre><p>Initialize a G-Computation estimator.</p><p>For a good overview of G-Computation see:     Chatton, Arthur, Florent Le Borgne, Clémence Leyrat, Florence Gillaizeau, Chloé      Rousseau, Laetitia Barbin, David Laplaud, Maxime Léger, Bruno Giraudeau, and Yohann      Foucher. &quot;G-computation, propensity score-based methods, and targeted maximum likelihood      estimator for causal inference with different covariates sets: a comparative simulation      study.&quot; Scientific reports 10, no. 1 (2020): 9219.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>X::Any</code>: an array or DataFrame of covariates.</li><li><code>T::Any</code>: an vector or DataFrame of treatment statuses.</li><li><code>Y::Any</code>: an array or DataFrame of outcomes.</li><li><code>task::String</code>: either regression or classification.</li><li><code>quantity_of_interest::String</code>: ATE for average treatment effect or CTE for cummulative    treatment effect.</li><li><code>regularized::Function=true</code>: whether to use L2 regularization</li><li><code>activation::Function=relu</code>: the activation function to use.</li><li><code>validation_metric::Function</code>: the validation metric to calculate during cross validation.</li><li><code>min_neurons::Int</code>: the minimum number of neurons to consider for the extreme learner.</li><li><code>max_neurons::Int</code>: the maximum number of neurons to consider for the extreme learner.</li><li><code>folds::Int</code>: the number of folds to use for cross validation.</li><li><code>iterations::Int</code>: the number of iterations to perform cross validation between    min<em>neurons and max</em>neurons.</li><li><code>approximator_neurons::Int</code>: the number of nuerons in the validation loss approximator    network.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), rand(100), [rand()&lt;0.4 for i in 1:100]
julia&gt; m1 = GComputation(X, T, Y)
julia&gt; m2 = GComputation(X, T, Y; task=&quot;regression&quot;)
julia&gt; m3 = GComputation(X, T, Y; task=&quot;regression&quot;, quantity_of_interest=&quot;ATE)
julia&gt; m4 = GComputation(X, T, Y; task=&quot;regression&quot;, quantity_of_interest=&quot;ATE, 
julia&gt; regularized=true)
julia&gt; x_df = DataFrame(x1=rand(100), x2=rand(100), x3=rand(100), x4=rand(100))
julia&gt; t_df, y_df = DataFrame(t=rand(0:1, 100)), DataFrame(y=rand(100)) 
julia&gt; m5 = GComputation(x_df, t_df, y_df)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/estimators.jl#L95-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.DoubleMachineLearning" href="#CausalELM.DoubleMachineLearning"><code>CausalELM.DoubleMachineLearning</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DoubleMachineLearning(X, T, Y; &lt;keyword arguments&gt;)</code></pre><p>Initialize a double machine learning estimator with cross fitting.</p><p>For more information see:     Chernozhukov, Victor, Denis Chetverikov, Mert Demirer, Esther Duflo, Christian Hansen,      Whitney Newey, and James Robins. &quot;Double/debiased machine learning for treatment and      structural parameters.&quot; (2016): C1-C68.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>X::Any</code>: an array or DataFrame of covariates of interest.</li><li><code>T::Any</code>: an vector or DataFrame of treatment statuses.</li><li><code>Y::Any</code>: an array or DataFrame of outcomes.</li><li><code>W::Any</code>: an array or dataframe of all possible confounders.</li><li><code>task::String</code>: either regression or classification.</li><li><code>quantity_of_interest::String</code>: ATE for average treatment effect or CTE for cummulative    treatment effect.</li><li><code>regularized::Function=true</code>: whether to use L2 regularization</li><li><code>activation::Function=relu</code>: the activation function to use.</li><li><code>validation_metric::Function</code>: the validation metric to calculate during cross validation.</li><li><code>min_neurons::Int</code>: the minimum number of neurons to consider for the extreme learner.</li><li><code>max_neurons::Int</code>: the maximum number of neurons to consider for the extreme learner.</li><li><code>folds::Int</code>: the number of folds to use for cross validation.</li><li><code>iterations::Int</code>: the number of iterations to perform cross validation between    min<em>neurons and max</em>neurons.</li><li><code>approximator_neurons::Int</code>: the number of nuerons in the validation loss approximator    network.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = DoubleMachineLearning(X, T, Y)
julia&gt; m2 = DoubleMachineLearning(X, T, Y; task=&quot;regression&quot;)
julia&gt; x_df = DataFrame(x1=rand(100), x2=rand(100), x3=rand(100), x4=rand(100))
julia&gt; t_df, y_df = DataFrame(t=rand(0:1, 100)), DataFrame(y=rand(100))
julia&gt; m3 = DoubleMachineLearning(x_df, t_df, y_df)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/estimators.jl#L194-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.SLearner" href="#CausalELM.SLearner"><code>CausalELM.SLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SLearner(X, T, Y; &lt;keyword arguments&gt;)</code></pre><p>Initialize a S-Learner.</p><p>For an overview of S-Learners and other metalearners see:     Künzel, Sören R., Jasjeet S. Sekhon, Peter J. Bickel, and Bin Yu. &quot;Metalearners for      estimating heterogeneous treatment effects using machine learning.&quot; Proceedings of the      national academy of sciences 116, no. 10 (2019): 4156-4165.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>X::Any</code>: an array or DataFrame of covariates.</li><li><code>T::Any</code>: an vector or DataFrame of treatment statuses.</li><li><code>Y::Any</code>: an array or DataFrame of outcomes.</li><li><code>task::String</code>: either regression or classification.</li><li><code>regularized::Function=true</code>: whether to use L2 regularization</li><li><code>activation::Function=relu</code>: the activation function to use.</li><li><code>validation_metric::Function</code>: the validation metric to calculate during cross validation.</li><li><code>min_neurons::Int</code>: the minimum number of neurons to consider for the extreme learner.</li><li><code>max_neurons::Int</code>: the maximum number of neurons to consider for the extreme learner.</li><li><code>folds::Int</code>: the number of folds to use for cross validation.</li><li><code>iterations::Int</code>: the number of iterations to perform cross validation between    min<em>neurons and max</em>neurons.</li><li><code>approximator_neurons::Int</code>: the number of nuerons in the validation loss approximator    network.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = SLearner(X, T, Y)
julia&gt; m2 = SLearner(X, T, Y; task=&quot;regression&quot;)
julia&gt; m3 = SLearner(X, T, Y; task=&quot;regression&quot;, regularized=true)
julia&gt; x_df = DataFrame(x1=rand(100), x2=rand(100), x3=rand(100), x4=rand(100))
julia&gt; t_df, y_df = DataFrame(t=rand(0:1, 100)), DataFrame(y=rand(100))
julia&gt; m4 = SLearner(x_df, t_df, y_df)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L4-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.TLearner" href="#CausalELM.TLearner"><code>CausalELM.TLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TLearner(X, T, Y; &lt;keyword arguments&gt;)</code></pre><p>Initialize a T-Learner.</p><p>For an overview of T-Learners and other metalearners see:     Künzel, Sören R., Jasjeet S. Sekhon, Peter J. Bickel, and Bin Yu. &quot;Metalearners for      estimating heterogeneous treatment effects using machine learning.&quot; Proceedings of the      national academy of sciences 116, no. 10 (2019): 4156-4165.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>X::Any</code>: an array or DataFrame of covariates.</li><li><code>T::Any</code>: an vector or DataFrame of treatment statuses.</li><li><code>Y::Any</code>: an array or DataFrame of outcomes.</li><li><code>task::String</code>: either regression or classification.</li><li><code>regularized::Function=true</code>: whether to use L2 regularization</li><li><code>activation::Function=relu</code>: the activation function to use.</li><li><code>validation_metric::Function</code>: the validation metric to calculate during cross validation.</li><li><code>min_neurons::Int</code>: the minimum number of neurons to consider for the extreme learner.</li><li><code>max_neurons::Int</code>: the maximum number of neurons to consider for the extreme learner.</li><li><code>folds::Int</code>: the number of folds to use for cross validation.</li><li><code>iterations::Int</code>: the number of iterations to perform cross validation between    min<em>neurons and max</em>neurons.</li><li><code>approximator_neurons::Int</code>: the number of nuerons in the validation loss approximator    network.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = TLearner(X, T, Y)
julia&gt; m2 = TLearner(X, T, Y; task=&quot;regression&quot;)
julia&gt; m3 = TLearner(X, T, Y; task=&quot;regression&quot;, regularized=true)
julia&gt; x_df = DataFrame(x1=rand(100), x2=rand(100), x3=rand(100), x4=rand(100))
julia&gt; t_df, y_df = DataFrame(t=rand(0:1, 100)), DataFrame(y=rand(100))
julia&gt; m4 = TLearner(x_df, t_df, y_df)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L60-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.RLearner" href="#CausalELM.RLearner"><code>CausalELM.RLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RLearner(X, T, Y; &lt;keyword arguments&gt;)</code></pre><p>Initialize an R-Learner.</p><p>For an explanation of R-Learner estimation see:     Nie, Xinkun, and Stefan Wager. &quot;Quasi-oracle estimation of heterogeneous treatment      effects.&quot; Biometrika 108, no. 2 (2021): 299-319.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>X::Any</code>: an array or DataFrame of covariates of interest.</li><li><code>T::Any</code>: an vector or DataFrame of treatment statuses.</li><li><code>Y::Any</code>: an array or DataFrame of outcomes.</li><li><code>W::Any</code> : an array of all possible confounders.</li><li><code>task::String</code>: either regression or classification.</li><li><code>regularized::Function=true</code>: whether to use L2 regularization</li><li><code>activation::Function=relu</code>: the activation function to use.</li><li><code>validation_metric::Function</code>: the validation metric to calculate during cross validation.</li><li><code>min_neurons::Int</code>: the minimum number of neurons to consider for the extreme learner.</li><li><code>max_neurons::Int</code>: the maximum number of neurons to consider for the extreme learner.</li><li><code>folds::Int</code>: the number of folds to use for cross validation.</li><li><code>iterations::Int</code>: the number of iterations to perform cross validation between    min<em>neurons and max</em>neurons.</li><li><code>approximator_neurons::Int</code>: the number of nuerons in the validation loss approximator    network.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = RLearner(X, T, Y)
julia&gt; m2 = RLearner(X, T, Y; t_cat=true)
julia&gt; x_df = DataFrame(x1=rand(100), x2=rand(100), x3=rand(100), x4=rand(100))
julia&gt; t_df, y_df = DataFrame(t=rand(0:1, 100)), DataFrame(y=rand(100))
julia&gt; m4 = RLearner(x_df, t_df, y_df)
julia&gt; w = rand(100, 6)
julia&gt; m5 = RLearner(X, T, Y, W=w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L238-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.CausalEstimator" href="#CausalELM.CausalEstimator"><code>CausalELM.CausalEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for GComputation and DoubleMachineLearning</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/estimators.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.Metalearner" href="#CausalELM.Metalearner"><code>CausalELM.Metalearner</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for metalearners</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.ExtremeLearningMachine" href="#CausalELM.ExtremeLearningMachine"><code>CausalELM.ExtremeLearningMachine</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type that includes vanilla and L2 regularized Extreme Learning Machines</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/models.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.ExtremeLearner" href="#CausalELM.ExtremeLearner"><code>CausalELM.ExtremeLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExtremeLearner(X, Y, hidden_neurons, activation)</code></pre><p>Construct an ExtremeLearner for fitting and prediction.</p><p>While it is possible to use an ExtremeLearner for regression, it is recommended to use  RegularizedExtremeLearner, which imposes an L2 penalty, to reduce multicollinearity.</p><p>For more details see:      Huang, Guang-Bin, Qin-Yu Zhu, and Chee-Kheong Siew. &quot;Extreme learning machine: theory      and applications.&quot; Neurocomputing 70, no. 1-3 (2006): 489-501.</p><p>See also <a href="@ref">&#39;RegularizedExtremeLearner&#39;</a>.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x = [1.0 1.0; 0.0 1.0; 0.0 0.0; 1.0 0.0]
4×2 Matrix{Float64}:
 1.0  1.0
 0.0 1.0
 0.0 0.0
 1.0 0.0
julia&gt; y = [0.0, 1.0, 0.0, 1.0]
 4-element Vector{Int64}:
 0.0
 1.0
 0.0
 1.0
julia&gt; m1 = ExtremeLearner(x, y, 10, σ)
Extreme Learning Machine with 10 hidden neurons</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/models.jl#L6-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.RegularizedExtremeLearner" href="#CausalELM.RegularizedExtremeLearner"><code>CausalELM.RegularizedExtremeLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularizedExtremeLearner(X, Y, hidden_neurons, activation)</code></pre><p>Construct a RegularizedExtremeLearner for fitting and prediction.</p><p>For more details see:      Li, Guoqiang, and Peifeng Niu. &quot;An enhanced extreme learning machine based on ridge      regression for regression.&quot; Neural Computing and Applications 22, no. 3 (2013):      803-810.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x = [1.0 1.0; 0.0 1.0; 0.0 0.0; 1.0 0.0]
4×2 Matrix{Float64}:
 1.0  1.0
 0.0 1.0
 0.0 0.0
 1.0 0.0
julia&gt; y = [0.0, 1.0, 0.0, 1.0]
4-element Vector{Int64}:
 0.0
 1.0
 0.0
 1.0
julia&gt; m1 = RegularizedExtremeLearner(x, y, 10, σ)
Regularized Extreme Learning Machine with 10 hidden neurons</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/models.jl#L57-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.Nonbinary" href="#CausalELM.Nonbinary"><code>CausalELM.Nonbinary</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type used to dispatch risk_ratio on nonbinary treatments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.Binary" href="#CausalELM.Binary"><code>CausalELM.Binary</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type used to dispatch risk_ratio on binary treatments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.Count" href="#CausalELM.Count"><code>CausalELM.Count</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type used to dispatch risk_ratio on count treatments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.Continuous" href="#CausalELM.Continuous"><code>CausalELM.Continuous</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type used to dispatch risk_ratio on continuous treatments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L10">source</a></section></article><h2 id="Activation-Functions"><a class="docs-heading-anchor" href="#Activation-Functions">Activation Functions</a><a id="Activation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Activation-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalELM.binary_step" href="#CausalELM.binary_step"><code>CausalELM.binary_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">binary_step(x)</code></pre><p>Apply the binary step activation function to a real number.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; binary_step(1)
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L1-L11">source</a></section><section><div><pre><code class="nohighlight hljs">binary_step(x)</code></pre><p>Apply the binary step activation function to an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; binary_step([-1000, 100, 1, 0, -0.001, -3])
6-element Vector{Float64}
 0.0 
 1.0 
 1.0 
 1.0 
 0.0 
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L14-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.σ" href="#CausalELM.σ"><code>CausalELM.σ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">σ(x)</code></pre><p>Apply the sigmoid activation function to a real number.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; σ(1)
 0.7310585786300049</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L33-L43">source</a></section><section><div><pre><code class="nohighlight hljs">σ(x)</code></pre><p>Apply the sigmoid activation function to an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; σ([1, 0])
2-element Vector{Float64}
 0.7310585786300049
 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L49-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.tanh" href="#Base.tanh"><code>Base.tanh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tanh(x)</code></pre><p>Apply the tanh activation function to an array.</p><p>This is just a vectorized version of Base.tanh</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; tanh([1, 0])
2-element Vector{Float64}
 0.7615941559557649 
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L64-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.relu" href="#CausalELM.relu"><code>CausalELM.relu</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">relu(x)</code></pre><p>Apply the ReLU activation function to a real number.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; relu(1)
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L81-L91">source</a></section><section><div><pre><code class="nohighlight hljs">relu(x)</code></pre><p>Apply the ReLU activation function to an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; relu([1, 0, -1])
3-element Vector{Float64}
 1.0 
 0.0 
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L94-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.leaky_relu" href="#CausalELM.leaky_relu"><code>CausalELM.leaky_relu</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leaky_relu(x)</code></pre><p>Apply the leaky ReLU activation function to a real number.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; leaky_relu(1)
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L110-L120">source</a></section><section><div><pre><code class="nohighlight hljs">leaky_relu(x)</code></pre><p>Apply the leaky ReLU activation function to an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; leaky_relu([-0.01, 0, 1])
3-element Vector{Float64}
 1.0 
 0.0 
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L123-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.swish" href="#CausalELM.swish"><code>CausalELM.swish</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swish(x)</code></pre><p>Apply the swish activation function to a real number.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; swish(1)
 0.7310585786300049</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L139-L149">source</a></section><section><div><pre><code class="nohighlight hljs">swish(x)</code></pre><p>Apply the swish activation function to an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; swish([1, 0, -1])
3-element Vector{Float64}
 0.7310585786300049 
 0.0 
 -0.2689414213699951</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L152-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.softmax" href="#CausalELM.softmax"><code>CausalELM.softmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">softmax(x)</code></pre><p>Apply the softmax activation function to a real number.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; softmax(1)
 2.718281828459045</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L168-L178">source</a></section><section><div><pre><code class="nohighlight hljs">softmax(x)</code></pre><p>Apply the softmax activation function to a vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; softmax([1, 2, 3])
3-element Vector{Float64}:
 0.09003057317038046
 0.24472847105479767
 0.6652409557748219</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L181-L194">source</a></section><section><div><pre><code class="nohighlight hljs">softmax(x)</code></pre><p>Apply the softmax activation function to the rows of an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; x = rand(5, 3)
5×3 Matrix{Float64}:
 0.482117  0.225359  0.615589
 0.255572  0.165051  0.427035
 0.387384  0.424856  0.369219
 0.175362  0.172561  0.111878
 0.508207  0.258347  0.591111
julia&gt; softmax(x)
5×3 Matrix{Float64}:
 0.342895  0.265248  0.391857
 0.322529  0.294616  0.382855
 0.331106  0.343749  0.325146
 0.340635  0.339682  0.319682
 0.348998  0.271838  0.379164</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L197-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.softplus" href="#CausalELM.softplus"><code>CausalELM.softplus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">softplus(x)</code></pre><p>Apply the softplus activation function to a real number.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; softplus(1)
 1.3132616875182228</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L222-L232">source</a></section><section><div><pre><code class="nohighlight hljs">softplus(x)</code></pre><p>Apply the softplus activation function to an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; softplus([1, -1])
2-element Vector{Float64}
 1.3132616875182228 
 0.31326168751822286</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L235-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.gelu" href="#CausalELM.gelu"><code>CausalELM.gelu</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gelu(x)</code></pre><p>Apply the GeLU activation function to a real number.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; gelu(1)
 0.8411919906082768</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L250-L260">source</a></section><section><div><pre><code class="nohighlight hljs">gelu(x)</code></pre><p>Apply the GeLU activation function to an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; gelu([-1, 0, 1])
3-element Vector{Float64}
 -0.15880800939172324 
 0.0 
 0.8411919906082768</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L263-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.gaussian" href="#CausalELM.gaussian"><code>CausalELM.gaussian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gaussian(x)</code></pre><p>Apply the gaussian activation function to a real number.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; gaussian(1)
 0.11443511435028261</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L279-L289">source</a></section><section><div><pre><code class="nohighlight hljs">gaussian(x)</code></pre><p>Apply the gaussian activation function to an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; gaussian([1, -1])
2-element Vector{Float64}
 0.36787944117144233 
 0.36787944117144233</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L292-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.hard_tanh" href="#CausalELM.hard_tanh"><code>CausalELM.hard_tanh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hard_tanh(x)</code></pre><p>Apply the hard_tanh activation function to a real number.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; hard_tanh(-2)
 -1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L307-L317">source</a></section><section><div><pre><code class="nohighlight hljs">hard_tanh(x)</code></pre><p>Apply the hard_tanh activation function to an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; hard_tanh([-2, 0, 2])
3-element Vector{Float64}
 -1.0 
 0.0 
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L328-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.elish" href="#CausalELM.elish"><code>CausalELM.elish</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elish(x)</code></pre><p>Apply the ELiSH activation function to a real number.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; elish(1)
 0.7310585786300049</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L344-L354">source</a></section><section><div><pre><code class="nohighlight hljs">elish(x)</code></pre><p>Apply the ELiSH activation function to an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; elish([-1, 1])
2-element Vector{Float64}
 -0.17000340156854793 
 0.7310585786300049</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L357-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.fourier" href="#CausalELM.fourier"><code>CausalELM.fourier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fourrier(x)</code></pre><p>Apply the Fourier activation function to a real number.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; fourier(1)
 0.8414709848078965</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L372-L382">source</a></section><section><div><pre><code class="nohighlight hljs">fourrier(x)</code></pre><p>Apply the Fourier activation function to an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; fourier([-1, 1])
2-element Vector{Float64}
 -0.8414709848078965 
 0.8414709848078965</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/activation.jl#L385-L397">source</a></section></article><h2 id="Cross-Validation"><a class="docs-heading-anchor" href="#Cross-Validation">Cross Validation</a><a id="Cross-Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-Validation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalELM.generate_folds" href="#CausalELM.generate_folds"><code>CausalELM.generate_folds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_folds(X, Y, folds)</code></pre><p>Creates folds for cross validation.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; xfolds, y_folds = generate_folds(zeros(20, 2), zeros(20), 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/crossval.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.generate_temporal_folds" href="#CausalELM.generate_temporal_folds"><code>CausalELM.generate_temporal_folds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_folds(X, Y, folds)</code></pre><p>Creates rolling folds for cross validation of time series data.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; xfolds, y_folds = generate_temporal_folds(zeros(20, 2), zeros(20), 5, temporal=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/crossval.jl#L36-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.validation_loss" href="#CausalELM.validation_loss"><code>CausalELM.validation_loss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">validation_loss(xtrain, ytrain, xtest, ytest, nodes, metric; &lt;keyword arguments&gt;)</code></pre><p>Calculate a validation metric for a single fold in k-fold cross validation.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>xtrain::Any</code>: an array of features to train on.</li><li><code>ytrain::Any</code>: an array of training labels.</li><li><code>xtest::Any</code>: an array of features to test on.</li><li><code>ytrain::Any</code>: an array of testing labels.</li><li><code>nodes::Int</code>: the number of neurons in the extreme learning machine.</li><li><code>metric::Function</code>: the validation metric to calculate.</li><li><code>activation::Function=relu</code>: the activation function to use.</li><li><code>regularized::Function=true</code>: whether to use L2 regularization.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x = rand(100, 5); y = Float64.(rand(100) .&gt; 0.5)
julia&gt; validation_loss(x, y, 5, accuracy, 3)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/crossval.jl#L61-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.cross_validate" href="#CausalELM.cross_validate"><code>CausalELM.cross_validate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cross_validate(X, Y, neurons, metric, activation, regularized, folds, temporal)</code></pre><p>...</p><p><strong>Arguments</strong></p><ul><li><code>X::Array</code>: an array of features to train on.</li><li><code>Y::Vector</code>: a vector of labels to train on.</li><li><code>neurons::Int</code>: the number of neurons to use in the extreme learning machine.</li><li><code>metric::Function</code>: the validation metric to calculate.</li><li><code>activation::Function=relu</code>: the activation function to use.</li><li><code>regularized::Function=true</code>: whether to use L2 regularization</li><li><code>folds::Int</code>: the number of folds to use for cross validation.</li><li><code>temporal::Function=true</code>: whether the data is of a time series or panel nature.</li></ul><p>...</p><p>Calculate a validation metric for k folds using a single set of hyperparameters.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x = rand(100, 5); y = Float64.(rand(100) .&gt; 0.5)
julia&gt; cross_validate(x, y, 5, accuracy)
0.0257841765251021</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/crossval.jl#L100-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.best_size" href="#CausalELM.best_size"><code>CausalELM.best_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">best_size(X, Y, metric, task, activation, min_neurons, max_neurons, regularized, folds, 
          temporal, iterations, elm_size)</code></pre><p>Compute the best number of neurons for an Extreme Learning Machine.</p><p>The procedure tests networks with numbers of neurons in a sequence whose length is given  by iterations on the interval [min<em>neurons, max</em>neurons]. Then, it uses the networks  sizes and validation errors from the sequence to predict the validation error or metric  for every network size between min<em>neurons and max</em>neurons using the function  approximation ability of an Extreme Learning Machine. Finally, it returns the network  size with the best predicted validation error or metric.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>X::Array</code>: an array of features to train on.</li><li><code>Y::Vector</code>: a vector of labels to train on.</li><li><code>metric::Function</code>: the validation metric to calculate.</li><li><code>task::String</code>: either regression or classification.</li><li><code>activation::Function=relu</code>: the activation function to use.</li><li><code>min_neurons::Int</code>: the minimum number of neurons to consider for the extreme learner.</li><li><code>max_neurons::Int</code>: the maximum number of neurons to consider for the extreme learner.</li><li><code>regularized::Function=true</code>: whether to use L2 regularization</li><li><code>folds::Int</code>: the number of folds to use for cross validation.</li><li><code>temporal::Function=true</code>: whether the data is of a time series or panel nature.</li><li><code>iterations::Int</code>: the number of iterations to perform cross validation between    min<em>neurons and max</em>neurons.</li><li><code>elm_size::Int</code>: the number of nuerons in the validation loss approximator network.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; best_size(rand(100, 5), rand(100), mse, &quot;regression&quot;)
11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/crossval.jl#L148-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.shuffle_data" href="#CausalELM.shuffle_data"><code>CausalELM.shuffle_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shuffle_data(X, Y)</code></pre><p>Shuffles covariates and outcome vector for cross validation.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x, y, t = rand(100, 5), rand(100), [rand()&lt;0.4 for i in 1:100]
julia&gt; shuffle_data(x, y, t)
([0.6124923085225416 0.2713900065807924 … 0.6094796972512194 0.6067966603192685; 
0.7186612932571539 0.8047878363606299 … 0.9787878554455594 0.885819212905816; … ; 
0.773543733306263 0.10880091279797399 … 0.10525512055751185 0.6303472234021711; 
0.10845217539341823 0.9911071602976902 … 0.014754069216096566 0.5256103389041187], 
[0.4302689295553531, 0.2396683446618325, 0.7954433314513768, 0.7191098533903124, 
0.8168563428651753, 0.7064320936729905, 0.048113106979693065, 0.3102938851371281, 
0.6246380539228858, 0.3510284321966193  …  0.5324022501182528, 0.8354720951777901, 
0.7526652774981095, 0.3639742621882005, 0.21030903031988923, 0.6936212944871928, 
0.3910592143534404, 0.15152013651215301, 0.38891692138831735, 0.08827711410802941], 
Float64[0, 0, 1, 1, 0, 1, 0, 0, 1, 0  …  0, 0, 1, 1, 1, 1, 0, 1, 0, 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/crossval.jl#L206-L226">source</a></section></article><h2 id="Average-Causal-Effect-Estimators"><a class="docs-heading-anchor" href="#Average-Causal-Effect-Estimators">Average Causal Effect Estimators</a><a id="Average-Causal-Effect-Estimators-1"></a><a class="docs-heading-anchor-permalink" href="#Average-Causal-Effect-Estimators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalELM.XLearner" href="#CausalELM.XLearner"><code>CausalELM.XLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">XLearner(X, T, Y; &lt;keyword arguments&gt;)</code></pre><p>Initialize an X-Learner.</p><p>For an overview of X-Learners and other metalearners see:     Künzel, Sören R., Jasjeet S. Sekhon, Peter J. Bickel, and Bin Yu. &quot;Metalearners for      estimating heterogeneous treatment effects using machine learning.&quot; Proceedings of the      national academy of sciences 116, no. 10 (2019): 4156-4165.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>X::Any</code>: an array or DataFrame of covariates.</li><li><code>T::Any</code>: an vector or DataFrame of treatment statuses.</li><li><code>Y::Any</code>: an array or DataFrame of outcomes.</li><li><code>task::String</code>: either regression or classification.</li><li><code>regularized::Function=true</code>: whether to use L2 regularization</li><li><code>activation::Function=relu</code>: the activation function to use.</li><li><code>validation_metric::Function</code>: the validation metric to calculate during cross validation.</li><li><code>min_neurons::Int</code>: the minimum number of neurons to consider for the extreme learner.</li><li><code>max_neurons::Int</code>: the maximum number of neurons to consider for the extreme learner.</li><li><code>folds::Int</code>: the number of folds to use for cross validation.</li><li><code>iterations::Int</code>: the number of iterations to perform cross validation between    min<em>neurons and max</em>neurons.</li><li><code>approximator_neurons::Int</code>: the number of nuerons in the validation loss approximator    network.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = XLearner(X, T, Y)
julia&gt; m2 = XLearner(X, T, Y; task=&quot;regression&quot;)
julia&gt; m3 = XLearner(X, T, Y; task=&quot;regression&quot;, regularized=true)
julia&gt; x_df = DataFrame(x1=rand(100), x2=rand(100), x3=rand(100), x4=rand(100))
julia&gt; t_df, y_df = DataFrame(t=rand(0:1, 100)), DataFrame(y=rand(100))
julia&gt; m4 = XLearner(x_df, t_df, y_df)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L148-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.estimate_effect!" href="#CausalELM.estimate_effect!"><code>CausalELM.estimate_effect!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_effect!(DML, cate=false)</code></pre><p>Estimate a treatment effect using double machine learning.</p><p>This method should not be called directly.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>DML::DoubleMachineLearning</code>: the DoubleMachineLearning struct to estimate the effect for.</li><li><code>cate::Bool=false</code>: whether to estimate the cate.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = DoubleMachineLearning(X, T, Y)
julia&gt; estimate_effect!(m1)
 0.31067439</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/estimators.jl#L397-L417">source</a></section><section><div><pre><code class="nohighlight hljs">estimate_effect!(DRE, X, T, Y, Z)</code></pre><p>Estimate the CATE for a single cross fitting iteration via doubly robust estimation.</p><p>This method should not be called directly.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>DRE::DoublyRobustLearner</code>: the DoubleMachineLearning struct to estimate the effect for.</li><li><code>X</code>: a vector of three covariate folds.</li><li><code>T</code>: a vector of three treatment folds.</li><li><code>Y</code>: a vector of three outcome folds.</li><li><code>Z</code> : a vector of three confounder folds and covariate folds.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y, W =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100), rand(6, 100)
julia&gt; m1 = DoublyRobustLearner(X, T, Y, W=W)
julia&gt; X, T, W, Y = make_folds(m1)
julia&gt; Z = m1.W == m1.X ? X : [reduce(hcat, (z)) for z in zip(X, W)]
julia&gt; estimate_effect!(m1, X, T, Y, Z)
100-element Vector{Float64}:
 0.015000753139197576
 0.6505590641524845
 ⋮
 0.5165324805032647</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L619-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.predict_residuals" href="#CausalELM.predict_residuals"><code>CausalELM.predict_residuals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predict_residuals(DML, x_train, x_test, y_train, y_test, t_train, t_test)</code></pre><p>Predict treatment and outcome residuals for doubl machine learning.</p><p>This method should not be called directly.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; x_train, x_test = X[1:80, :], X[81:end, :]
julia&gt; y_train, y_test = Y[1:80], Y[81:end]
julia&gt; t_train, t_test = T[1:80], T[81:100]
julia&gt; m1 = DoubleMachineLearning(X, T, Y)
julia&gt; predict_residuals(m1, x_train, x_test, y_train, y_test, t_train, t_test)
100-element Vector{Float64}
 0.6944714802199426
 0.6102318624294397
 0.9563033347529682
 ⋮
 0.14016601301278353, 
 0.2217194742841072
 0.199372555924635</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/estimators.jl#L445-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.moving_average" href="#CausalELM.moving_average"><code>CausalELM.moving_average</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moving_average(x)</code></pre><p>Calculates a cumulative moving average.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; moving_average([1, 2, 3])
3-element Vector{Float64}
 1.0
 1.5
 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/estimators.jl#L521-L534">source</a></section></article><h2 id="Metalearners"><a class="docs-heading-anchor" href="#Metalearners">Metalearners</a><a id="Metalearners-1"></a><a class="docs-heading-anchor-permalink" href="#Metalearners" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalELM.stage1!" href="#CausalELM.stage1!"><code>CausalELM.stage1!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>stage1!(x)</p><p>Estimate the first stage models for an X-learner.</p><p>This method should not be called by the user.</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = XLearner(X, T, Y)
julia&gt; stage1!(m1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L676-L688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.stage2!" href="#CausalELM.stage2!"><code>CausalELM.stage2!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>stage2!(x)</p><p>Estimate the second stage models for an X-learner.</p><p>This method should not be called by the user.</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = XLearner(X, T, Y)
julia&gt; stage1!(m1)
julia&gt; stage2!(m1)
100-element Vector{Float64}
 0.6579129842054047
 0.7644471766429705
 0.5462780002052421
 ⋮
 0.8755515354984005
 0.947588000142362
 0.29294343704001025</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L710-L731">source</a></section></article><h2 id="Common-Methods"><a class="docs-heading-anchor" href="#Common-Methods">Common Methods</a><a id="Common-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalELM.estimate_causal_effect!" href="#CausalELM.estimate_causal_effect!"><code>CausalELM.estimate_causal_effect!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_causal_effect!(its)</code></pre><p>Estimate the effect of an event relative to a predicted counterfactual.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X₀, Y₀, X₁, Y₁ =  rand(100, 5), rand(100), rand(10, 5), rand(10)
julia&gt; m1 = InterruptedTimeSeries(X₀, Y₀, X₁, Y₁)
julia&gt; estimate_causal_effect!(m1)
 0.25714308</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/estimators.jl#L278-L290">source</a></section><section><div><pre><code class="nohighlight hljs">estimate_causal_effect!(g)</code></pre><p>Estimate a causal effect of interest using G-Computation.</p><p>If treatents are administered at multiple time periods, the effect will be estimated as the  average difference between the outcome of being treated in all periods and being treated in  no periods.For example, given that catividuals 1, 2, ..., i ∈ I recieved either a treatment  or a placebo in p different periods, the model would estimate the average treatment effect  as E[Yᵢ|T₁=1, T₂=1, ... Tₚ=1, Xₚ] - E[Yᵢ|T₁=0, T₂=0, ... Tₚ=0, Xₚ].</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = GComputation(X, T, Y)
julia&gt; estimate_causal_effect!(m1)
 0.31067439</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/estimators.jl#L314-L332">source</a></section><section><div><pre><code class="nohighlight hljs">estimate_causal_effect!(DML)</code></pre><p>Estimate a causal effect of interest using double machine learning.</p><p>Unlike other estimators, this method does not support time series or panel data. This method  also does not work as well with smaller datasets because it estimates separate outcome  models for the treatment and control groups.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = DoubleMachineLearning(X, T, Y)
julia&gt; estimate_causal_effect!(m1)
 0.31067439
julia&gt; W = rand(100, 6)
julia&gt; m2 = DoubleMachineLearning(X, T, Y, W=W)
julia&gt; estimate_causal_effect!(m2)
 0.7628583414839659</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/estimators.jl#L360-L380">source</a></section><section><div><pre><code class="nohighlight hljs">estimate_causal_effect!(s)</code></pre><p>Estimate the CATE using an S-learner.</p><p>For an overview of S-learning see:     Künzel, Sören R., Jasjeet S. Sekhon, Peter J. Bickel, and Bin Yu. &quot;Metalearners for      estimating heterogeneous treatment effects using machine learning.&quot; Proceedings of the      national academy of sciences 116, no. 10 (2019): 4156-4165.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m4 = SLearner(X, T, Y)
julia&gt; estimate_causal_effect!(m4)
100-element Vector{Float64}
 0.20729633391630697
 0.20729633391630697
 0.20729633391630692
 ⋮
 0.20729633391630697
 0.20729633391630697
 0.20729633391630697</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L375-L399">source</a></section><section><div><pre><code class="nohighlight hljs">estimate_causal_effect!(t)</code></pre><p>Estimate the CATE using an T-learner.</p><p>For an overview of T-learning see:     Künzel, Sören R., Jasjeet S. Sekhon, Peter J. Bickel, and Bin Yu. &quot;Metalearners for      estimating heterogeneous treatment effects using machine learning.&quot; Proceedings of the      national academy of sciences 116, no. 10 (2019): 4156-4165.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m5 = TLearner(X, T, Y)
julia&gt; estimate_causal_effect!(m5)
100-element Vector{Float64}
 0.0493951571746305
 0.049395157174630444
 0.0493951571746305
 ⋮ 
 0.049395157174630444
 0.04939515717463039
 0.049395157174630444</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L418-L442">source</a></section><section><div><pre><code class="nohighlight hljs">estimate_causal_effect!(x)</code></pre><p>Estimate the CATE using an X-learner.</p><p>For an overview of X-learning see:     Künzel, Sören R., Jasjeet S. Sekhon, Peter J. Bickel, and Bin Yu. &quot;Metalearners for      estimating heterogeneous treatment effects using machine learning.&quot; Proceedings of the      national academy of sciences 116, no. 10 (2019): 4156-4165.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = XLearner(X, T, Y)
julia&gt; estimate_causal_effect!(m1)
100-element Vector{Float64}
-0.025012644892878473
-0.024634294305967294
-0.022144246680543364
⋮ 
-0.021163590874553318
-0.014607310062509895
-0.022449034332142046</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L470-L494">source</a></section><section><div><pre><code class="nohighlight hljs">estimate_causal_effect!(R)</code></pre><p>Estimate the CATE using an R-learner.</p><p>For an overview of R-learning see:     Nie, Xinkun, and Stefan Wager. &quot;Quasi-oracle estimation of heterogeneous treatment      effects.&quot; Biometrika 108, no. 2 (2021): 299-319.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = RLearner(X, T, Y)
julia&gt; estimate_causal_effect!(m1)
100-element Vector{Float64}
 -0.025012644892878473
 -0.024634294305967294
 -0.022144246680543364
 ⋮
 -0.021163590874553318
 -0.014607310062509895 
-0.022449034332142046
julia&gt; m2 = RLearner(X, T, Y, W=w)
julia&gt; estimate_causal_effect!(m2)
100-element Vector{Float64}:
 0.5974338191923166
 0.08251194695862285
 ⋮
 0.8259613235225352
 0.8736987932637659</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L513-L544">source</a></section><section><div><pre><code class="nohighlight hljs">estimate_causal_effect!(DRE)</code></pre><p>Estimate the CATE using a doubly robust learner.</p><p>For details on how this method estimates the CATE see:     Kennedy, Edward H. &quot;Towards optimal doubly robust estimation of heterogeneous causal      effects.&quot; Electronic Journal of Statistics 17, no. 2 (2023): 3008-3049.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = DoublyRobustLearner(X, T, Y)
julia&gt; estimate_causal_effect!(m1)
100-element Vector{Float64}
 -0.025012644892878473
 -0.024634294305967294
 -0.022144246680543364
 ⋮
 -0.021163590874553318
 -0.014607310062509895 
-0.022449034332142046
julia&gt; X, T, Y, W =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100), rand(6, 100)
julia&gt; m2 = DoublyRobustLearner(X, T, Y, W=W)
julia&gt; estimate_effect!(m2)
100-element Vector{Float64}:
 0.015000753139197576
 0.6505590641524845
 ⋮
 0.5165324805032647</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metalearners.jl#L563-L594">source</a></section></article><h2 id="Inference"><a class="docs-heading-anchor" href="#Inference">Inference</a><a id="Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Inference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalELM.summarize" href="#CausalELM.summarize"><code>CausalELM.summarize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">summarize(its, mean_effect)</code></pre><p>Return a summary from an interrupted time series estimator.</p><p>p-values and standard errors are estimated using approximate randomization inference that permutes the time of the intervention.</p><p>For a primer on randomization inference see:      https://www.mattblackwell.org/files/teaching/s05-fisher.pdf</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X₀, Y₀, X₁, Y₁ =  rand(100, 5), rand(100), rand(10, 5), rand(10)
julia&gt; m1 = InterruptedTimeSeries(X₀, Y₀, X₁, Y₁)
julia&gt; estimate_causal_effect!(m1)
1-element Vector{Float64}
 0.25714308
julia&gt; summarize(m1)
 {&quot;Task&quot; =&gt; &quot;Regression&quot;, &quot;Regularized&quot; =&gt; true, &quot;Activation Function&quot; =&gt; relu, 
 &quot;Validation Metric&quot; =&gt; &quot;mse&quot;,&quot;Number of Neurons&quot; =&gt; 2, 
 &quot;Number of Neurons in Approximator&quot; =&gt; 10, &quot;β&quot; =&gt; [0.25714308], 
 &quot;Causal Effect&quot; =&gt; -3.9101138, &quot;Standard Error&quot; =&gt; 1.903434356, &quot;p-value&quot; = 0.00123356}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/inference.jl#L3-L27">source</a></section><section><div><pre><code class="nohighlight hljs">summarize(mod, n)</code></pre><p>Return a summary from a CausalEstimator or Metalearner.</p><p>p-values and standard errors are estimated using approximate randomization inference.</p><p>For a primer on randomization inference see:      https://www.mattblackwell.org/files/teaching/s05-fisher.pdf</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = GComputation(X, T, Y)
julia&gt; estimate_causal_effect!(m1)
 0.3100468253
julia&gt; summarize(m1)
 {&quot;Task&quot; =&gt; &quot;Regression&quot;, &quot;Quantity of Interest&quot; =&gt; &quot;ATE&quot;, Regularized&quot; =&gt; &quot;true&quot;, 
 &quot;Activation Function&quot; =&gt; &quot;relu&quot;, &quot;Time Series/Panel Data&quot; =&gt; &quot;false&quot;, 
 &quot;Validation Metric&quot; =&gt; &quot;mse&quot;,&quot;Number of Neurons&quot; =&gt; &quot;5&quot;, 
 &quot;Number of Neurons in Approximator&quot; =&gt; &quot;10&quot;, &quot;Causal Effect: 0.00589761, 
 &quot;Standard Error&quot; =&gt; 5.12900734, &quot;p-value&quot; =&gt; 0.479011245} </code></pre><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = RLearner(X, T, Y)
julia&gt; estimate_causal_effect(m1)
1-element Vector{Float64}
 [0.5804032956]
julia&gt; summarize(m1)
 {&quot;Task&quot; =&gt; &quot;Regression&quot;, &quot;Quantity of Interest&quot; =&gt; &quot;ATE&quot;, Regularized&quot; =&gt; &quot;true&quot;, 
 &quot;Activation Function&quot; =&gt; &quot;relu&quot;, &quot;Validation Metric&quot; =&gt; &quot;mse&quot;, &quot;Number of Neurons&quot; =&gt; &quot;5&quot;, 
 &quot;Number of Neurons in Approximator&quot; =&gt; &quot;10&quot;, &quot;Causal Effect&quot; = 0.5804032956, 
 &quot;Standard Error&quot; =&gt; 2.129400324, &quot;p-value&quot; =&gt; 0.0008342356}</code></pre><pre><code class="language-julia hljs">julia&gt; X, T, Y =  rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(100)
julia&gt; m1 = SLearner(X, T, Y)
julia&gt; estimate_causal_effect!(m1)
100-element Vector{Float64}
 0.20729633391630697
 0.20729633391630697
 0.20729633391630692
 ⋮
 0.20729633391630697
 0.20729633391630697
 0.20729633391630697
julia&gt; summarise(m1)
 {&quot;Task&quot; =&gt; &quot;Regression&quot;, Regularized&quot; =&gt; &quot;true&quot;, &quot;Activation Function&quot; =&gt; &quot;relu&quot;, 
 &quot;Validation Metric&quot; =&gt; &quot;mse&quot;, &quot;Number of Neurons&quot; =&gt; &quot;5&quot;, 
 &quot;Number of Neurons in Approximator&quot; =&gt; &quot;10&quot;, 
 &quot;Causal Effect: [0.20729633391630697, 0.20729633391630697, 0.20729633391630692, 
 0.20729633391630697, 0.20729633391630697, 0.20729633391630697, 0.20729633391630697, 
 0.20729633391630703, 0.20729633391630697, 0.20729633391630697  …  0.20729633391630703, 
 0.20729633391630697, 0.20729633391630692, 0.20729633391630703, 0.20729633391630697, 
 0.20729633391630697, 0.20729633391630692, 0.20729633391630697, 0.20729633391630697, 
 0.20729633391630697], &quot;Standard Error&quot; =&gt; 5.3121435085, &quot;p-value&quot; =&gt; 0.0632454855}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/inference.jl#L52-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.generate_null_distribution" href="#CausalELM.generate_null_distribution"><code>CausalELM.generate_null_distribution</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_null_distribution(mod, n)</code></pre><p>Generate a null distribution for the treatment effect of G-computation, double machine  learning, or metalearning.</p><p>This method estimates the same model that is provided using random permutations of the  treatment assignment to generate a vector of estimated effects under different treatment regimes. When mod is a metalearner the null statistic is the difference is the ATE.</p><p>Note that lowering the number of iterations increases the probability of failing to reject the null hypothesis.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x, t, y = rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(1:100, 100, 1)
julia&gt; g_computer = GComputation(x, t, y)
julia&gt; estimate_causal_effect!(g_computer)
julia&gt; generate_null_distribution(g_computer, 500)
500-element Vector{Float64}
500-element Vector{Float64}
 0.016297180690693656
 0.0635928694685571
 0.20004144093635673
 ⋮
 24.739658523175912
 25.30523686137909
 28.07474553316176</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/inference.jl#L143-L172">source</a></section><section><div><pre><code class="nohighlight hljs">generate_null_distribution(its, n, mean_effect)</code></pre><p>Generate a null distribution for the treatment effect in an interrupted time series  analysis. By default, this method generates a null distribution of mean differences. To  generate a null distribution of cummulative differences, set the mean_effect argument to  false.</p><p>Randomization is conducted by randomly assigning observations to the pre and  post-intervention periods, resestimating the causal effect, and repeating n times. The null  distribution is the set of n casual effect estimates.</p><p>Note that lowering the number of iterations increases the probability of failing to reject the null hypothesis.</p><p>For a primer on randomization inference see:      https://www.mattblackwell.org/files/teaching/s05-fisher.pdf</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x₀, y₀, x₁, y₁ = rand(1:100, 100, 5), rand(100), rand(10, 5), rand(10)
julia&gt; its = InterruptedTimeSeries(x₀, y₀, x₁, y₁)
julia&gt; estimate_causale_ffect!(its)
julia&gt; generate_null_distribution(its, 10)
10-element Vector{Float64}
 -0.5012456678829079
 -0.33790650529972194
 -0.2534340182760628
 ⋮
 -0.06217013151235991 
 -0.05905529159312335
 -0.04927743270606937</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/inference.jl#L194-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.quantities_of_interest" href="#CausalELM.quantities_of_interest"><code>CausalELM.quantities_of_interest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quantities_of_interest(mod, n)</code></pre><p>Generate a p-value and standard error through randomization inference</p><p>This method generates a null distribution of treatment effects by reestimating treatment  effects from permutations of the treatment vector and estimates a p-value and standard from the generated distribution.</p><p>Note that lowering the number of iterations increases the probability of failing to reject the null hypothesis.</p><p>For a primer on randomization inference see:     https://www.mattblackwell.org/files/teaching/s05-fisher.pdf</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x, t, y = rand(100, 5), [rand()&lt;0.4 for i in 1:100], rand(1:100, 100, 1)
julia&gt; g_computer = GComputation(x, t, y)
julia&gt; estimate_causal_effect!(g_computer)
julia&gt; quantities_of_interest(g_computer, 1000)
 (0.114, 6.953133617011371)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/inference.jl#L251-L274">source</a></section><section><div><pre><code class="nohighlight hljs">quantities_of_interest(mod, n)</code></pre><p>Generate a p-value and standard error through randomization inference</p><p>This method generates a null distribution of treatment effects by reestimating treatment  effects from permutations of the treatment vector and estimates a p-value and standard from  the generated distribution. Randomization for event studies is done by creating time splits  at even intervals and reestimating the causal effect.</p><p>Note that lowering the number of iterations increases the probability of failing to reject the null hypothesis.</p><p>For a primer on randomization inference see:     https://www.mattblackwell.org/files/teaching/s05-fisher.pdf</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x₀, y₀, x₁, y₁ = rand(1:100, 100, 5), rand(100), rand(10, 5), rand(10)
julia&gt; its = InterruptedTimeSeries(x₀, y₀, x₁, y₁)
julia&gt; estimate_causal_effect!(its)
julia&gt; quantities_of_interest(its, 10)
 (0.0, 0.07703275541001667)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/inference.jl#L287-L311">source</a></section></article><h2 id="Model-Validation"><a class="docs-heading-anchor" href="#Model-Validation">Model Validation</a><a id="Model-Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Validation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalELM.validate" href="#CausalELM.validate"><code>CausalELM.validate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">validate(its; &lt;keyword arguments&gt;)</code></pre><p>Test the validity of an estimated interrupted time series analysis.</p><p>This method coducts a Chow Test, a Wald supremeum test, and tests the model&#39;s sensitivity to  confounders. The Chow Test tests for structural breaks in the covariates between the time  before and after the event. p-values represent the proportion of times the magnitude of the  break in a covariate would have been greater due to chance. Lower p-values suggest a higher  probability the event effected the covariates and they cannot provide unbiased  counterfactual predictions. The Wald supremum test finds the structural break with the  highest Wald statistic. If this is not the same as the hypothesized break, it could indicate  an anticipation effect, a confounding event, or that the intervention or policy took place  in multiple phases. p-values represent the proportion of times we would see a larger Wald  statistic if the data points were randomly allocated to pre and post-event periods for the  predicted structural break. Ideally, the hypothesized break will be the same as the  predicted break and it will also have a low p-value. The omitted predictors test adds  normal random variables with uniform noise as predictors. If the included covariates are  good predictors of the counterfactual outcome, adding irrelevant predictors should not have  a large effect on the predicted counterfactual outcomes or the estimated effect.</p><p>For more details on the assumptions and validity of interrupted time series designs, see:     Baicker, Katherine, and Theodore Svoronos. Testing the validity of the single      interrupted time series design. No. w26080. National Bureau of Economic Research, 2019.</p><ul><li>Note that this method does not implement the second test in Baicker and Svoronos because </li></ul><p>the estimator in this package models the relationship between covariates and the outcome and  uses an extreme learning machine instead of linear regression, so variance in the outcome  across different bins is not much of an issue.</p><p>For a primer on randomization inference see:      https://www.mattblackwell.org/files/teaching/s05-fisher.pdf</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>its::InterruptedTimeSeries</code>: an interrupted time seiries estimator.</li><li><code>n::Int</code>: the number of times to simulate a confounder.</li><li><code>low::Float64</code>=0.15: the minimum proportion of data points to include before or after the    tested break in the Wald supremum test.</li><li><code>high::Float64=0.85</code>: the maximum proportion of data points to include before or after the    tested break in the Wald supremum test.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; X₀, Y₀, X₁, Y₁ =  rand(100, 5), rand(100), rand(10, 5), rand(10)
julia&gt; m1 = InterruptedTimeSeries(X₀, Y₀, X₁, Y₁)
julia&gt; estimate_causal_effect!(m1)
[0.25714308]
julia&gt; validate(m1)
{&quot;Task&quot; =&gt; &quot;Regression&quot;, &quot;Regularized&quot; =&gt; true, &quot;Activation Function&quot; =&gt; relu, 
&quot;Validation Metric&quot; =&gt; &quot;mse&quot;,&quot;Number of Neurons&quot; =&gt; 2, 
&quot;Number of Neurons in Approximator&quot; =&gt; 10, &quot;β&quot; =&gt; [0.25714308], 
&quot;Causal Effect&quot; =&gt; -3.9101138, &quot;Standard Error&quot; =&gt; 1.903434356, &quot;p-value&quot; = 0.00123356}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L35-L90">source</a></section><section><div><pre><code class="nohighlight hljs">validate(m; &lt;keyword arguments&gt;)</code></pre><p>This method tests the counterfactual consistency, exchangeability, and positivity  assumptions required for causal inference. It should be noted that consistency and  exchangeability are not directly testable, so instead, these tests do not provide definitive  evidence of a violation of these assumptions. To probe the counterfactual consistency  assumption, we assume there were multiple levels of treatments and find them by binning the dependent vairable for treated observations using Jenks breaks. The optimal number of breaks  between 2 and num_treatments is found using the elbow method. Using these hypothesized  treatment assignemnts, this method compares the MSE of linear regressions using the observed  and hypothesized treatments. If the counterfactual consistency assumption holds then the  difference between the MSE with hypothesized treatments and the observed treatments should  be positive because the hypothesized treatments should not provide useful information. If  it is negative, that indicates there was more useful information provided by the  hypothesized treatments than the observed treatments or that there is an unobserved  confounder. Next, this methods tests the model&#39;s sensitivity to a violation of the  exchangeability assumption by calculating the E-value, which is the minimum strength of  association, on the risk ratio scale, that an unobserved confounder would need to have with  the treatment and outcome variable to fully explain away the estimated effect. Thus, higher  E-values imply the model is more robust to a violation of the exchangeability assumption.  Finally, this method tests the positivity assumption by estimating propensity scores. Rows in the matrix are levels of covariates that have a zero probability of treatment. If the  matrix is empty, none of the observations have an estimated zero probability of treatment,  which implies the positivity assumption is satisfied.</p><p>For a thorough review of casual inference assumptions see:     Hernan, Miguel A., and James M. Robins. Causal inference what if. Boca Raton: Taylor and      Francis, 2024. </p><p>For more information on the E-value test see:     VanderWeele, Tyler J., and Peng Ding. &quot;Sensitivity analysis in observational research:      introducing the E-value.&quot; Annals of internal medicine 167, no. 4 (2017): 268-274.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>m::Union{CausalEstimator, Metalearner}</code>: a model to validate/test the assumptions of.</li><li><code>num_treatments=5::Int</code>: the maximum number of treatments to use when testing the    plausability of the counterfactual consistency assumption.</li><li><code>min::Float64</code>=1.0e-6: minimum probability of treatment for the positivity assumption.</li><li><code>high::Float64=1-min</code>: the maximum probability of treatment for the positivity assumption.</li></ul><p>...</p><p>Examples <code>julia julia&gt; x, t, y = rand(100, 5), Float64.([rand()&lt;0.4 for i in 1:100]),              vec(rand(1:100, 100, 1)),  julia&gt; g_computer = GComputation(x, t, y, temporal=false) julia&gt; estimate_causal_effect!(g_computer) julia&gt; validate(g_computer)  2.7653668647301795</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L100-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.covariate_independence" href="#CausalELM.covariate_independence"><code>CausalELM.covariate_independence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">covariate_independence(its; &lt;keyword arguments&gt;)</code></pre><p>Test for independence between covariates and the event or intervention.</p><p>This is a Chow Test for covariates with p-values estimated via randomization inference. The  p-values are the proportion of times randomly assigning observations to the pre or  post-intervention period would have a larger estimated effect on the the slope of the  covariates. The lower the p-values, the more likely it is that the event/intervention  effected the covariates and they cannot provide an unbiased prediction of the counterfactual  outcomes.</p><p>For more information on using a Chow Test to test for structural breaks see:     Baicker, Katherine, and Theodore Svoronos. Testing the validity of the single      interrupted time series design. No. w26080. National Bureau of Economic Research, 2019.</p><p>For a primer on randomization inference see:      https://www.mattblackwell.org/files/teaching/s05-fisher.pdf</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>its::InterruptedTImeSeries</code>: an interrupted time seiries estimator.</li><li><code>n::Int</code>: the number of permutations for assigning observations to the pre and    post-treatment periods.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x₀, y₀, x₁, y₁ = (Float64.(rand(1:5, 100, 5)), randn(100), rand(1:5, (10, 5)), 
           randn(10))
julia&gt; its = InterruptedTimeSeries(x₀, y₀, x₁, y₁)
julia&gt; estimate_causal_effect!(its)
julia&gt; covariate_independence(its)
 Dict(&quot;Column 1 p-value&quot; =&gt; 0.421, &quot;Column 5 p-value&quot; =&gt; 0.07, &quot;Column 3 p-value&quot; =&gt; 0.01, 
 &quot;Column 2 p-value&quot; =&gt; 0.713, &quot;Column 4 p-value&quot; =&gt; 0.043)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L176-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.omitted_predictor" href="#CausalELM.omitted_predictor"><code>CausalELM.omitted_predictor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">omitted_predictor(its; &lt;keyword arguments&gt;)</code></pre><p>See how an omitted predictor/variable could change the results of an interrupted time series  analysis.</p><p>This method reestimates interrupted time series models with uniform random variables. If the  included covariates are good predictors of the counterfactual outcome, adding a random  variable as a covariate should not have a large effect on the predicted counterfactual  outcomes and therefore the estimated average effect.</p><p>For more information on using a Chow Test to test for structural breaks see:     Baicker, Katherine, and Theodore Svoronos. Testing the validity of the single      interrupted time series design. No. w26080. National Bureau of Economic Research, 2019.</p><p>For a primer on randomization inference see:      https://www.mattblackwell.org/files/teaching/s05-fisher.pdf</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>its::InterruptedTImeSeries</code>: an interrupted time seiries estimator.</li><li><code>n::Int</code>: the number of times to simulate a confounder.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x₀, y₀, x₁, y₁ = (Float64.(rand(1:5, 100, 5)), randn(100), rand(1:5, (10, 5)), 
           randn(10))
julia&gt; its = InterruptedTimeSeries(x₀, y₀, x₁, y₁)
julia&gt; estimate_causal_effect!(its)
julia&gt; omitted_predictor(its)
 Dict(&quot;Mean Biased Effect/Original Effect&quot; =&gt; -0.1943184744720332, &quot;Median Biased 
 Effect/Original Effect&quot; =&gt; -0.1881814122689084, &quot;Minimum Biased Effect/Original Effect&quot; =&gt; 
 -0.2725194360603799, &quot;Maximum Biased Effect/Original Effect&quot; =&gt; -0.1419197976977072)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L231-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.sup_wald" href="#CausalELM.sup_wald"><code>CausalELM.sup_wald</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sup_wald(its; &lt;keyword arguments&gt;)</code></pre><p>Check if the predicted structural break is the hypothesized structural break.</p><p>This method conducts Wald tests and identifies the structural break with the highest Wald  statistic. If this break is not the same as the hypothesized break, it could indicate an  anticipation effect, confounding by some other event or intervention, or that the  intervention or policy took place in multiple phases. p-values are estimated using  approximate randomization inference and represent the proportion of times we would see a  larger Wald statistic if the data points were randomly allocated to pre and post-event  periods for the predicted structural break.</p><p>For more information on using a Chow Test to test for structural breaks see:     Baicker, Katherine, and Theodore Svoronos. Testing the validity of the single      interrupted time series design. No. w26080. National Bureau of Economic Research, 2019.</p><p>For a primer on randomization inference see:      https://www.mattblackwell.org/files/teaching/s05-fisher.pdf</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>its::InterruptedTimeSeries</code>: an interrupted time seiries estimator.</li><li><code>n::Int</code>: the number of times to simulate a confounder.</li><li><code>low::Float64</code>=0.15: the minimum proportion of data points to include before or after the    tested break in the Wald supremum test.</li><li><code>high::Float64=0.85</code>: the maximum proportion of data points to include before or after the    tested break in the Wald supremum test.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x₀, y₀, x₁, y₁ = (Float64.(rand(1:5, 100, 5)), randn(100), rand(1:5, (10, 5)), 
           randn(10))
julia&gt; its = InterruptedTimeSeries(x₀, y₀, x₁, y₁)
julia&gt; estimate_causal_effect!(its)
julia&gt; sup_wald(its)
 Dict{String, Real}(&quot;Wald Statistic&quot; =&gt; 58.16649796321913, &quot;p-value&quot; =&gt; 0.005, &quot;Predicted 
 Break Point&quot; =&gt; 39, &quot;Hypothesized Break Point&quot; =&gt; 100)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L293-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.p_val" href="#CausalELM.p_val"><code>CausalELM.p_val</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">p_val(x, y, β; &lt;keyword arguments&gt;)</code></pre><p>Estimate the p-value for the hypothesis that an event had a statistically significant effect  on the slope of a covariate using randomization inference.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>x::Array{&lt;:Real}</code>: covariates.</li><li><code>y::Array{&lt;:Real}</code>: the outcome.</li><li><code>β::Array{&lt;:Real}</code>=0.15: the fitted weights.</li><li><code>two_sided::Bool=false</code>: whether to conduct a one-sided hypothesis test.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x, y, β = reduce(hcat, (float(rand(0:1, 10)), ones(10))), rand(10), 0.5
julia&gt; p_val(x, y, β)
 0.98
julia&gt; p_val(x, y, β; n=100, two_sided=true)
 0.08534054</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L360-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.counterfactual_consistency" href="#CausalELM.counterfactual_consistency"><code>CausalELM.counterfactual_consistency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">counterfactual_consistency(m; &lt;keyword arguments&gt;)</code></pre><p>Examine the counterfactual consistency assumption. First, this function generates Jenks  breaks based on outcome values for the treatment group. Then, it replaces treatment statuses  with the numbers corresponding to each group. Next, it runs two models, one for the  treatment group, one with and one without the fake treatment assignemnts generated by  the Jenks breaks. Finally, it subtracts the mean squared error from the regression with real  data from the mean squared error from the regression with the fake treatment statuses. If  this number is negative, it might indicate a violation of the counterfactual consistency  assumption or omitted variable bias.</p><p>For a primer on G-computation and its assumptions see:     Naimi, Ashley I., Stephen R. Cole, and Edward H. Kennedy. &quot;An introduction to g      methods.&quot; International journal of epidemiology 46, no. 2 (2017): 756-762.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>m::Union{CausalEstimator, Metalearner}</code>: a model to validate/test the assumptions of.</li><li><code>num_treatments=5::Int</code>: the maximum number of treatments to use when testing the    plausability of the counterfactual consistency assumption.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x, t, y = rand(100, 5), Float64.([rand()&lt;0.4 for i in 1:100], 
            vec(rand(1:100, 100, 1)))
julia&gt; g_computer = GComputation(x, t, y, temporal=false)
julia&gt; estimate_causal_effect!(g_computer)
julia&gt; counterfactual_consistency(g_computer)
 2.7653668647301795</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L408-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.exchangeability" href="#CausalELM.exchangeability"><code>CausalELM.exchangeability</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exchangeability(model)</code></pre><p>Test the sensitivity of a G-computation or doubly robust estimator or metalearner to a  violation of the exchangeability assumption.</p><p>For more information on the E-value test see:     VanderWeele, Tyler J., and Peng Ding. &quot;Sensitivity analysis in observational research:      introducing the E-value.&quot; Annals of internal medicine 167, no. 4 (2017): 268-274.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x, t, y = rand(100, 5), Float64.([rand()&lt;0.4 for i in 1:100], 
            vec(rand(1:100, 100, 1)))
julia&gt; g_computer = GComputation(x, t, y, temporal=false)
julia&gt; estimate_causal_effect!(g_computer)
julia&gt; e_value(g_computer)
 1.13729886008143832</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L454-L473">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.e_value" href="#CausalELM.e_value"><code>CausalELM.e_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">e_value(model)</code></pre><p>Test the sensitivity of an estimator to a violation of the exchangeability assumption.</p><p>For more information on the E-value test see:     VanderWeele, Tyler J., and Peng Ding. &quot;Sensitivity analysis in observational research:      introducing the E-value.&quot; Annals of internal medicine 167, no. 4 (2017): 268-274.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x, t, y = rand(100, 5), Float64.([rand()&lt;0.4 for i in 1:100], 
            vec(rand(1:100, 100, 1)))
julia&gt; g_computer = GComputation(x, t, y, temporal=false)
julia&gt; estimate_causal_effect!(g_computer)
julia&gt; e_value(g_computer)
 2.2555405766985125</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L476-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.binarize" href="#CausalELM.binarize"><code>CausalELM.binarize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">binarize(x, cutoff)</code></pre><p>Convert a vector of counts or a continuous vector to a binary vector.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; binarize([1, 2, 3], 2)
3-element Vector{Int64}:
 0
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L505-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.risk_ratio" href="#CausalELM.risk_ratio"><code>CausalELM.risk_ratio</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">risk_ratio(model)</code></pre><p>Calculate the risk ratio for an estimated model.</p><p>If the treatment variable is not binary and the outcome variable is not continuous then the  treatment variable will be binarized.</p><p>For more information on how other quantities of interest are converted to risk ratios see:     VanderWeele, Tyler J., and Peng Ding. &quot;Sensitivity analysis in observational research:      introducing the E-value.&quot; Annals of internal medicine 167, no. 4 (2017): 268-274.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x, t, y = rand(100, 5), Float64.([rand()&lt;0.4 for i in 1:100], 
            vec(rand(1:100, 100, 1)))
julia&gt; g_computer = GComputation(x, t, y, temporal=false)
julia&gt; estimate_causal_effect!(g_computer)
julia&gt; risk_ratio(g_computer)
 2.5320694766985125</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L529-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.positivity" href="#CausalELM.positivity"><code>CausalELM.positivity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">positivity(model[,min][,max])</code></pre><p>Find likely violations of the positivity assumption.</p><p>This method uses an extreme learning machine or regularized extreme learning machine to  estimate probabilities of treatment. The returned matrix, which may be empty, are the  covariates that have a (near) zero probability of treatment or near zero probability of  being assigned to the control group, whith their entry in the last column being their  estimated treatment probability. In other words, they likely violate the positivity  assumption.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>model::Union{CausalEstimator, Metalearner}</code>: a model to validate/test the assumptions of.</li><li><code>min::Float64</code>=1.0e-6: minimum probability of treatment for the positivity assumption.</li><li><code>high::Float64=1-min</code>: the maximum probability of treatment for the positivity assumption.</li></ul><p>...</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; x, t, y = rand(100, 5), Float64.([rand()&lt;0.4 for i in 1:100], 
            vec(rand(1:100, 100, 1)))
julia&gt; g_computer = GComputation(x, t, y, temporal=false)
julia&gt; estimate_causal_effect!(g_computer)
julia&gt; positivity(g_computer)
0×5 Matrix{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L629-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.sums_of_squares" href="#CausalELM.sums_of_squares"><code>CausalELM.sums_of_squares</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sums_of_squares(data, num_classes)</code></pre><p>Calculate the minimum sum of squares for each data point and class for the Jenks breaks      algorithm.</p><p>This should not be called by the user.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; sums_of_squares([1, 2, 3, 4, 5], 2)
5×2 Matrix{Real}:
 0.0       0.0
 0.25      0.25
 0.666667  0.666667
 1.25      1.16667
 2.0       1.75</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L704-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.class_pointers" href="#CausalELM.class_pointers"><code>CausalELM.class_pointers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">class_pointers(data, num_classes, sums_of_sqs)</code></pre><p>Compute class pointers that minimize the sum of squares for Jenks breaks.</p><p>This should not be callled by the user.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; sums_squares = sums_of_sqs::Matrix{Float64}
5×2 Matrix{Float64}:
 0.0       0.0
 0.25      0.25
 0.666667  0.666667
 1.25      1.16667
 2.0       1.75
julia&gt; class_pointers([1, 2, 3, 4, 5], 2, sums_squares)
5×2 Matrix{Int64}:
 1  0
 1  1
 1  1
 1  1
 1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L743-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.backtrack_to_find_breaks" href="#CausalELM.backtrack_to_find_breaks"><code>CausalELM.backtrack_to_find_breaks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">backtrack_to_find_breaks(data, num_classes, sums_of_sqs)</code></pre><p>Determine break points from class assignments.</p><p>This should not be called by the user.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; data = [1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
5-element Vector{Int64}:
 1
 2
 3
 4
 5
julia&gt; ptr = class_pointers([1, 2, 3, 4, 5], 2, sums_of_squares([1, 2, 3, 4, 5], 2))
5×2 Matrix{Int64}:
 1  28
 1   1
 1   1
 1   1
 1   1
julia&gt; backtrack_to_find_breaks([1, 2, 3, 4, 5], ptr)
2-element Vector{Int64}:
 1
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L788-L817">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.variance" href="#CausalELM.variance"><code>CausalELM.variance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">variance(data)</code></pre><p>Calculate the variance of some numbers.</p><p>Note this function does not use Besel&#39;s correction.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; variance([1, 2, 3, 4, 5])
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L839-L851">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.best_splits" href="#CausalELM.best_splits"><code>CausalELM.best_splits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">best_splits(data, num_classes)</code></pre><p>Find the best number of splits for Jenks breaks.</p><p>This function finds the best number of splits by finding the number of splits that results      in the greatest decrease in the slope of the line between itself and its GVF and the      next higher number of splits and its GVF. This is the same thing as the elbow method.</p><p>This should nto be called by the user.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; best_splits(collect(1:10), 5)
10-element Vector{Int64}:
 1
 3
 3
 ⋮
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L859-L881">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.group_by_class" href="#CausalELM.group_by_class"><code>CausalELM.group_by_class</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">group_by_class(data, classes)</code></pre><p>Group data points into vectors such that data points assigned to the same class are in the  same vector.</p><p>This should nto be called by the user.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; group_by_class([1, 2, 3, 4, 5], [1, 1, 1, 2, 3])
3-element Vector{Vector{Real}}:
 [1, 2, 3]
 [4]
 [5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L895-L911">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.jenks_breaks" href="#CausalELM.jenks_breaks"><code>CausalELM.jenks_breaks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jenks_breaks(data, num_classes)</code></pre><p>Generate Jenks breaks for a vector of real numbers.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; jenks_breaks([1, 2, 3, 4, 5], 3)
3-element Vector{Int64}:
 1
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L929-L942">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.fake_treatments" href="#CausalELM.fake_treatments"><code>CausalELM.fake_treatments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fake_treatments(data, num_classes)</code></pre><p>Generate fake treatment statuses corresponding to the classes assigned by the Jenks breaks  algorithm.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; fake_treatments([1, 2, 3, 4, 5], 4)
5-element Vector{Int64}:
 1
 2
 3
 4
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L952-L968">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.sdam" href="#CausalELM.sdam"><code>CausalELM.sdam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sdam(x)</code></pre><p>Calculate the sum of squared deviations for array mean for a set of sub arrays.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; sdam([5, 4, 9, 10]) 
26.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L991-L1001">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.scdm" href="#CausalELM.scdm"><code>CausalELM.scdm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sdcm(x)</code></pre><p>Calculate the sum of squared deviations for class means for a set of sub arrays.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; scdm([[4], [5, 9, 10]]) 
14.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L1008-L1018">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.gvf" href="#CausalELM.gvf"><code>CausalELM.gvf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gvf(x)</code></pre><p>Calculate the goodness of variance fit for a set of sub vectors.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; gvf([[4, 5], [9, 10]])
0.96153846153</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L1021-L1031">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.var_type" href="#CausalELM.var_type"><code>CausalELM.var_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">var_type(x)</code></pre><p>Determine the type of variable held by a vector.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; var_type([1, 2, 3, 2, 3, 1, 1, 3, 2])
Binary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/model_validation.jl#L13-L23">source</a></section></article><h2 id="Validation-Metrics"><a class="docs-heading-anchor" href="#Validation-Metrics">Validation Metrics</a><a id="Validation-Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Validation-Metrics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalELM.mse" href="#CausalELM.mse"><code>CausalELM.mse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mse(y, ŷ)</code></pre><p>Calculate the mean squared error</p><p>See also <a href="#CausalELM.mae"><code>mae</code></a>.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; mse([0.0, 0.0, 0.0], [0.0, 0.0, 0.0])
 0.0
julia&gt; mse([-1.0, -1.0, -1.0], [1.0, 1.0, 1.0])
 4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metrics.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.mae" href="#CausalELM.mae"><code>CausalELM.mae</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mae(y, ŷ)</code></pre><p>Calculate the mean absolute error</p><p>See also <a href="#CausalELM.mse"><code>mse</code></a>.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; mae([-1.0, -1.0, -1.0], [1.0, 1.0, 1.0])
 2.0
julia&gt; mae([1.0, 1.0, 1.0], [2.0, 2.0, 2.0])
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metrics.jl#L26-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.accuracy" href="#CausalELM.accuracy"><code>CausalELM.accuracy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">accuracy(y, ŷ)</code></pre><p>Calculate the accuracy for a classification task</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; accuracy([1, 1, 1, 1], [0, 1, 1, 0])
 0.5
julia&gt; accuracy([1, 2, 3, 4], [1, 1, 1, 1])
 0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metrics.jl#L49-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.precision" href="#Base.precision"><code>Base.precision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">precision(y, ŷ)</code></pre><p>Calculate the precision for a classification task</p><p>See also <a href="#CausalELM.recall"><code>recall</code></a>.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; precision([0, 1, 0, 0], [0, 1, 1, 0])
 0.5
julia&gt; precision([0, 1, 0, 0], [0, 1, 0, 0])
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metrics.jl#L76-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.recall" href="#CausalELM.recall"><code>CausalELM.recall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">recall(y, ŷ)</code></pre><p>Calculate the recall for a classification task</p><p>See also <a href="#Base.precision"><code>precision</code></a>.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; recall([1, 2, 1, 3, 0], [2, 2, 2, 3, 1])
 0.5
julia&gt; recall([1, 2, 1, 3, 2], [2, 2, 2, 3, 1])
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metrics.jl#L105-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.F1" href="#CausalELM.F1"><code>CausalELM.F1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">F1(y, ŷ)</code></pre><p>Calculate the F1 score for a classification task</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; F1([1, 2, 1, 3, 0], [2, 2, 2, 3, 1])
 0.4
julia&gt; F1([1, 2, 1, 3, 2], [2, 2, 2, 3, 1])
 0.47058823529411764</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metrics.jl#L134-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.confusion_matrix" href="#CausalELM.confusion_matrix"><code>CausalELM.confusion_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">confusion_matrix(y, ŷ)</code></pre><p>Generate a confusion matrix</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; confusion_matrix([1, 1, 1, 1, 0], [1, 1, 1, 1, 0])
2×2 Matrix{Int64}:
 1  0
 0 4
julia&gt; confusion_matrix([1, 1, 1, 1, 0, 2], [1, 1, 1, 1, 0, 2])
3×3 Matrix{Int64}:
 1  0 0
 0 4 0
 0 0 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/metrics.jl#L152-L169">source</a></section></article><h2 id="Extreme-Learning-Machines"><a class="docs-heading-anchor" href="#Extreme-Learning-Machines">Extreme Learning Machines</a><a id="Extreme-Learning-Machines-1"></a><a class="docs-heading-anchor-permalink" href="#Extreme-Learning-Machines" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalELM.fit!" href="#CausalELM.fit!"><code>CausalELM.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(model)</code></pre><p>Make predictions with an ExtremeLearner.</p><p>For more details see:      Huang, Guang-Bin, Qin-Yu Zhu, and Chee-Kheong Siew. &quot;Extreme learning machine: theory      and applications.&quot; Neurocomputing 70, no. 1-3 (2006): 489-501.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; m1 = ExtremeLearner(x, y, 10, σ)
 Extreme Learning Machine with 10 hidden neurons
 julia&gt; f1 = fit!(m1)
 10-element Vector{Float64}
 -4.403356409043448
 -5.577616954029608
 -2.1732800642523595
 ⋮
 -2.4741301876094655
 40.642730531608635
 -11.058942121275233</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/models.jl#L105-L128">source</a></section><section><div><pre><code class="nohighlight hljs">fit!(model)</code></pre><p>Fit a Regularized Extreme Learner.</p><p>For more details see:      Li, Guoqiang, and Peifeng Niu. &quot;An enhanced extreme learning machine based on ridge      regression for regression.&quot; Neural Computing and Applications 22, no. 3 (2013):      803-810.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; m1 = RegularizedExtremeLearner(x, y, 10, σ)
Regularized Extreme Learning Machine with 10 hidden neurons
julia&gt; f1 = fit!(m1)
10-element Vector{Float64}
 -4.403356409043448
 -5.577616954029608
 -2.1732800642523595
 ⋮
 -2.4741301876094655
 40.642730531608635
 -11.058942121275233</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/models.jl#L137-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.predict" href="#CausalELM.predict"><code>CausalELM.predict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predict(model, X)</code></pre><p>Use an ExtremeLearningMachine to make predictions.</p><p>For more details see:      Huang G-B, Zhu Q-Y, Siew C. Extreme learning machine: theory and applications.      Neurocomputing. 2006;70:489–501. https://doi.org/10.1016/j.neucom.2005.12.126</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; m1 = ExtremeLearner(x, y, 10, σ)
Extreme Learning Machine with 10 hidden neurons
julia&gt; f1 = fit(m1, sigmoid)
10-element Vector{Float64}
 -4.403356409043448
 -5.577616954029608
 -2.1732800642523595
 ⋮
 -2.4741301876094655
 40.642730531608635
 -11.058942121275233
julia&gt; predict(m1, [1.0 1.0; 0.0 1.0; 0.0 0.0; 1.0 0.0])
4-element Vector{Float64}
 9.811656638113011e-16
 0.9999999999999962
 -9.020553785284482e-17
 0.9999999999999978</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/models.jl#L175-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.predict_counterfactual!" href="#CausalELM.predict_counterfactual!"><code>CausalELM.predict_counterfactual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predictcounterfactual(model, X)</code></pre><p>Use an ExtremeLearningMachine to predict the counterfactual.</p><p>This should be run with the observed covariates. To use synthtic data for what-if      scenarios use predict.</p><p>See also <a href="#CausalELM.predict"><code>predict</code></a>.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; m1 = ExtremeLearner(x, y, 10, σ)
 Extreme Learning Machine with 10 hidden neurons
 julia&gt; f1 = fit(m1, sigmoid)
 10-element Vector{Float64}
 -4.403356409043448
 -5.577616954029608
 -2.1732800642523595
 ⋮
 -2.4741301876094655
 40.642730531608635
 -11.058942121275233
julia&gt; predict_counterfactual(m1, [1.0 1.0; 0.0 1.0; 0.0 0.0; 1.0 0.0])
4-element Vector{Float64}
 9.811656638113011e-16
 0.9999999999999962
 -9.020553785284482e-17
 0.9999999999999978</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/models.jl#L213-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.placebo_test" href="#CausalELM.placebo_test"><code>CausalELM.placebo_test</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">placebo_test(model)</code></pre><p>Conduct a placebo test.</p><p>This method makes predictions for the post-event or post-treatment period using data  in the pre-event or pre-treatment period and the post-event or post-treament. If there is a statistically significant difference between these predictions the study design may be flawed. Due to the multitude of significance tests for time series data, this function returns the predictions but does not test for statistical significance.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; m1 = ExtremeLearner(x, y, 10, σ)
Extreme Learning Machine with 10 hidden neurons
julia&gt; f1 = fit(m1, sigmoid)
10-element Vector{Float64}
 -4.403356409043448
 -5.577616954029608
 -2.1732800642523595
 ⋮
 -2.4741301876094655
 40.642730531608635
 -11.058942121275233
julia&gt; predict_counterfactual(m1, [1.0 1.0; 0.0 1.0; 0.0 0.0; 1.0 0.0])
4-element Vector{Float64}
 9.811656638113011e-16
 0.9999999999999962
 -9.020553785284482e-17
 0.9999999999999978
julia&gt; placebo_test(m1)
 ([9.811656638113011e-16, 0.9999999999999962, -9.020553785284482e-17, 0.9999999999999978],
 [0.5, 0.4, 0.3, 0.2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/models.jl#L250-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.ridge_constant" href="#CausalELM.ridge_constant"><code>CausalELM.ridge_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ridge_constant(model)</code></pre><p>Calculate the L2 penalty for a regularized extreme learning machine.</p><p>For more information see:      Li, Guoqiang, and Peifeng Niu. &quot;An enhanced extreme learning machine based on ridge      regression for regression.&quot; Neural Computing and Applications 22, no. 3 (2013):      803-810.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; m1 = RegularizedExtremeLearner(x, y, 10, σ)
Extreme Learning Machine with 10 hidden neurons
julia&gt; ridge_constant(m1)
 0.26789338524662887</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/models.jl#L293-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.set_weights_biases" href="#CausalELM.set_weights_biases"><code>CausalELM.set_weights_biases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_weights_biases(model)</code></pre><p>Calculate the weights and biases for an extreme learning machine or regularized extreme  learning machine.</p><p>For details see;     Huang, Guang-Bin, Qin-Yu Zhu, and Chee-Kheong Siew. &quot;Extreme learning machine: theory      and applications.&quot; Neurocomputing 70, no. 1-3 (2006): 489-501.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; m1 = RegularizedExtremeLearner(x, y, 10, σ)
Extreme Learning Machine with 10 hidden neurons
julia&gt; set_weights_biases(m1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/models.jl#L318-L334">source</a></section></article><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalELM.mean" href="#CausalELM.mean"><code>CausalELM.mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mean(x)</code></pre><p>Calculate the mean of a vector.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; mean([1, 2, 3, 4])
2.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/utilities.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.var" href="#CausalELM.var"><code>CausalELM.var</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">var(x)</code></pre><p>Calculate the (sample) mean of a vector.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; var([1, 2, 3, 4])
1.6666666666666667</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/utilities.jl#L14-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.consecutive" href="#CausalELM.consecutive"><code>CausalELM.consecutive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">consecutive(x)</code></pre><p>Subtract consecutive elements in a vector.</p><p>This function is only used to create a rolling average for interrupted time series analysis.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; consecutive([1, 2, 3, 4, 5])
4-element Vector{Int64}:
 1
 1
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/utilities.jl#L28-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalELM.one_hot_encode" href="#CausalELM.one_hot_encode"><code>CausalELM.one_hot_encode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">one_hot_encode(x)</code></pre><p>One hot encode a categorical vector for multiclass classification.</p><p>Examples</p><pre><code class="language-julia hljs">julia&gt; one_hot_encode([1, 2, 3, 4, 5])
5×5 Matrix{Float64}:
 1.0  0.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0
 0.0  0.0  0.0  1.0  0.0
 0.0  0.0  0.0  0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dscolby/CausalELM.jl/blob/e29ad2c0b67b1187dfd39620e2a5262bee75ee79/src/utilities.jl#L47-L62">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guide/doublyrobust/">« Doubly Robust Estimation</a><a class="docs-footer-nextpage" href="../contributing/">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">© 2024 Darren Colby</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 5 May 2024 03:21">Sunday 5 May 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
